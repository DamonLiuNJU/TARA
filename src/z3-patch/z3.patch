diff --git a/src/api/api_solver.cpp b/src/api/api_solver.cpp
index be03e5d..14f0202 100644
--- a/src/api/api_solver.cpp
+++ b/src/api/api_solver.cpp
@@ -33,6 +33,11 @@ Revision History:
 #include"smt_solver.h"
 #include"smt_implied_equalities.h"
 
+//BEGIN: ASHU
+Z3_ast_vector_ref* asserted_linear_constr = NULL;
+ast_ref_vector* asserted_linear_constr_vector;
+//END: ASHU
+
 extern "C" {
 
     static void init_solver_core(Z3_context c, Z3_solver _s) {
@@ -47,6 +52,13 @@ extern "C" {
         context_params::collect_solver_param_descrs(r);
         p.validate(r);
         s->m_solver->updt_params(p);
+        //BEGIN: ASHU
+        if (asserted_linear_constr == NULL) {
+          asserted_linear_constr = alloc(Z3_ast_vector_ref, mk_c(c)->m());
+          asserted_linear_constr_vector = &(asserted_linear_constr->m_ast_vector);
+          asserted_linear_constr->inc_ref();
+        }
+        //END: ASHU
     }
 
     static void init_solver(Z3_context c, Z3_solver s) {
@@ -413,4 +425,17 @@ extern "C" {
         Z3_CATCH_RETURN(Z3_L_UNDEF);
     }
 
+  //BEGIN: ASHU
+  //extern smt::smt_kernel* proper_kernel;
+
+  Z3_ast_vector Z3_API Z3_collect_last_asserted_linear_constr(void) {
+    return of_ast_vector(asserted_linear_constr);
+  }
+
+  void Z3_API Z3_delete_last_asserted_linear_constr(void) {
+    if (asserted_linear_constr != NULL)
+      asserted_linear_constr->dec_ref();
+  }
+  //END: ASHU
+
 };
diff --git a/src/api/c++/z3++.h b/src/api/c++/z3++.h
index 9fb6648..6ec9206 100644
--- a/src/api/c++/z3++.h
+++ b/src/api/c++/z3++.h
@@ -147,7 +147,7 @@ namespace z3 {
         context() { config c; init(c); }
         context(config & c) { init(c); }
 	context(config & c, interpolation) { init_interp(c); }
-        ~context() { Z3_del_context(m_ctx); }
+      ~context() { Z3_delete_last_asserted_linear_constr(); Z3_del_context(m_ctx); } // ASHU
         operator Z3_context() const { return m_ctx; }
 
         /**
@@ -248,6 +248,9 @@ namespace z3 {
 
         expr constant(symbol const & name, sort const & s);
         expr constant(char const * name, sort const & s);
+        //BEGIN: ASHU
+        expr fresh_constant(char const * name, sort const & s);// ASHU
+       //END: ASHU
         expr bool_const(char const * name);
         expr int_const(char const * name);
         expr real_const(char const * name);
@@ -279,6 +282,10 @@ namespace z3 {
 
         expr num_val(int n, sort const & s);
 
+      //BEGIN: ASHU
+      expr_vector collect_last_asserted_linear_constr(void);
+      //END: ASHU
+
         /**
            \brief Interpolation support
         */
@@ -546,6 +553,13 @@ namespace z3 {
         expr(expr const & n):ast(n) {}
         expr & operator=(expr const & n) { return static_cast<expr&>(ast::operator=(n)); }
 
+      //BEGIN: ASHU
+        bool get_bool() const {
+          Z3_lbool b = Z3_get_bool_value(*m_ctx, m_ast);
+          assert(b!=Z3_L_UNDEF);
+          return b==Z3_L_TRUE;
+        }
+      //END: ASHU
         /**
            \brief Return the sort of this expression.
         */
@@ -1820,6 +1834,14 @@ namespace z3 {
         }
     public:
         tactic(context & c, char const * name):object(c) { Z3_tactic r = Z3_mk_tactic(c, name); check_error(); init(r); }
+        tactic(tactic const & tactic, params const & params):object(tactic) {
+          Z3_param_descrs pd = Z3_tactic_get_param_descrs(ctx(), tactic);
+          Z3_param_descrs_inc_ref(ctx(), pd);
+          Z3_params_validate(ctx(), params, pd);
+          check_error();
+          Z3_param_descrs_dec_ref(ctx(), pd);
+          Z3_tactic r = Z3_tactic_using_params(tactic.ctx(), tactic, params); check_error(); init(r);
+        }
         tactic(context & c, Z3_tactic s):object(c) { init(s); }
         tactic(tactic const & s):object(s) { init(s.m_tactic); }
         ~tactic() { Z3_tactic_dec_ref(ctx(), m_tactic); }
@@ -2141,6 +2163,13 @@ namespace z3 {
         check_error();
         return expr(*this, r);
     }
+  //BEGIN: ASHU
+    inline expr context::fresh_constant(char const * name, sort const & s) {
+      Z3_ast r = Z3_mk_fresh_const(m_ctx, name, s);
+      check_error();
+      return expr(*this, r);
+    }
+  //END: ASHU
     inline expr context::constant(char const * name, sort const & s) { return constant(str_symbol(name), s); }
     inline expr context::bool_const(char const * name) { return constant(name, bool_sort()); }
     inline expr context::int_const(char const * name) { return constant(name, int_sort()); }
@@ -2407,7 +2436,24 @@ namespace z3 {
         return expr(ctx(), r);
     }
 
-
+  //BEGIN: ASHU
+    inline expr_vector context::collect_last_asserted_linear_constr(void) {
+      Z3_ast_vector asserted1 = Z3_collect_last_asserted_linear_constr();
+      z3::expr_vector asserted = expr_vector(*this, asserted1);
+      return asserted;
+    }
+
+    // inline expr distinct(expr_vector const& args) {
+    //   array<Z3_ast> _args(args.size());
+    //   for (unsigned i = 0; i < args.size(); i++) {
+    //     check_context(args.ctx(), args[i]);
+    //     _args[i] = args[i];
+    //   }
+    //   Z3_ast r = Z3_mk_distinct(args.ctx(), args.size(), _args.ptr());
+    //   args.ctx().check_error();
+    //   return expr(args.ctx(), r);
+    // }
+  //END: ASHU
 
 }
 
diff --git a/src/api/z3_api.h b/src/api/z3_api.h
index 1144900..9a86c03 100644
--- a/src/api/z3_api.h
+++ b/src/api/z3_api.h
@@ -6015,6 +6015,11 @@ extern "C" {
 
     /*@}*/
 
+  //BEGIN: ASHU
+  Z3_ast_vector Z3_API Z3_collect_last_asserted_linear_constr(void);
+  void Z3_API Z3_delete_last_asserted_linear_constr(void);
+  //END: ASHU
+
 #ifdef __cplusplus
 }
 #endif // __cplusplus
diff --git a/src/smt/smt_context.cpp b/src/smt/smt_context.cpp
index 07f4440..6eece6d 100644
--- a/src/smt/smt_context.cpp
+++ b/src/smt/smt_context.cpp
@@ -4148,6 +4148,12 @@ namespace smt {
         return m_last_search_failure; 
     }
 
+  //BEGIN: ASHU
+  void context::collect_asserted_linear_constr( ast_ref_vector& atoms ) {
+    m_model_generator->collect_asserted_linear_constr( atoms );
+  }
+  //END: ASHU
+
 };
 
 #ifdef Z3DEBUG
diff --git a/src/smt/smt_context.h b/src/smt/smt_context.h
index 8b2453e..38784f6 100644
--- a/src/smt/smt_context.h
+++ b/src/smt/smt_context.h
@@ -1467,6 +1467,10 @@ namespace smt {
         func_decl * get_macro_interpretation(unsigned i, expr_ref & interp) const { return m_asserted_formulas.get_macro_interpretation(i, interp); }
         quantifier * get_macro_quantifier(func_decl * f) const { return m_asserted_formulas.get_macro_quantifier(f); }
         void insert_macro(func_decl * f, quantifier * m, proof * pr) { m_asserted_formulas.insert_macro(f, m, pr); }
+
+      //BEGIN: ASHU
+      void collect_asserted_linear_constr( ast_ref_vector& );
+      //END: ASHU
     };
 
 };
diff --git a/src/smt/smt_kernel.cpp b/src/smt/smt_kernel.cpp
index 418dfdb..7838a1b 100644
--- a/src/smt/smt_kernel.cpp
+++ b/src/smt/smt_kernel.cpp
@@ -348,4 +348,10 @@ namespace smt {
         return m_imp->m_kernel;
     }
 
+  //BEGIN: ASHU
+  void kernel::collect_asserted_linear_constr( ast_ref_vector& atoms ) {
+    m_imp->m_kernel.collect_asserted_linear_constr( atoms );
+  }
+  //END: ASHU
+
 };
diff --git a/src/smt/smt_kernel.h b/src/smt/smt_kernel.h
index bf559a7..69b94de 100644
--- a/src/smt/smt_kernel.h
+++ b/src/smt/smt_kernel.h
@@ -241,6 +241,9 @@ namespace smt {
            \warning We should not use this method
         */
         context & get_context();
+      //BEGIN: ASHU
+      void collect_asserted_linear_constr( ast_ref_vector& );
+      //END: ASHU
     };
 };
 
diff --git a/src/smt/smt_model_generator.cpp b/src/smt/smt_model_generator.cpp
index 21a310a..3546599 100644
--- a/src/smt/smt_model_generator.cpp
+++ b/src/smt/smt_model_generator.cpp
@@ -32,7 +32,14 @@ namespace smt {
         m_context(0),
         m_fresh_idx(1),
         m_asts(m_manager),
-        m_model(0) {
+        m_model(0),
+        //BEGIN: ASHU
+        f1s(m_manager),
+        f2s(m_manager),
+        added_constr(m_manager),
+        assigned_atoms(m_manager)
+        //END: ASHU
+    {
     }
 
     model_generator::~model_generator() {
@@ -310,20 +317,24 @@ namespace smt {
               svector<source>::const_iterator it  = sources.begin();
               svector<source>::const_iterator end = sources.end();
               for (; it != end; ++it) {
-                  source const & curr = *it;
-                  if (curr.is_fresh_value()) {
-                      tout << "fresh!" << curr.get_value()->get_idx() << " " << mk_pp(curr.get_value()->get_sort(), m_manager) << "\n";
-                  }
-                  else {
-                      enode * n = curr.get_enode();
-                      SASSERT(n->get_root() == n);
-                      sort * s = m_manager.get_sort(n->get_owner());
-                      tout << "#" << n->get_owner_id() << " " << mk_pp(s, m_manager);
-                      model_value_proc * proc = 0;
-                      root2proc.find(n, proc);
-                      SASSERT(proc);
-                      tout << " is_fresh: " << proc->is_fresh() << "\n";
-                  }
+                //ASHU: changed printing
+                source const & curr = *it;
+                if ( curr.is_fresh_value() ) {
+                  tout << "fresh!" << curr.get_value()->get_idx() << " "
+                       << mk_pp(curr.get_value()->get_sort(), m_manager)
+                       << "\n";
+                } else {
+                  enode * n = curr.get_enode();
+                  SASSERT(n->get_root() == n);
+                  sort * s = m_manager.get_sort(n->get_owner());
+                  tout << "#" << n->get_owner_id() << ":= ";
+                  ast_ll_bounded_pp( tout, m_manager, n->get_owner(), 1);
+                  tout << ":" << mk_pp( s, m_manager );
+                  model_value_proc * proc = 0;
+                  root2proc.find(n, proc);
+                  SASSERT(proc);
+                  tout << " is_fresh: " << proc->is_fresh() << "\n";
+                }
               });
         svector<source>::const_iterator it  = sources.begin();
         svector<source>::const_iterator end = sources.end();
@@ -528,5 +539,5 @@ namespace smt {
         register_macros();
         return m_model;
     }
-    
+
 };
diff --git a/src/smt/smt_model_generator.h b/src/smt/smt_model_generator.h
index 6017176..92faf30 100644
--- a/src/smt/smt_model_generator.h
+++ b/src/smt/smt_model_generator.h
@@ -32,6 +32,9 @@ Revision History:
 #include"smt_types.h"
 #include"obj_hashtable.h"
 #include"map.h"
+//BEGIN: ASHU
+#include "func_interp.h"
+//END: ASHU
 
 class value_factory;
 class proto_model;
@@ -182,7 +185,12 @@ namespace smt {
         obj_map<enode, app *>         m_root2value;
         ast_ref_vector                m_asts;
         proto_model *                 m_model;
-
+      //BEGIN: ASHU
+      func_decl_ref_vector f1s;
+      func_decl_ref_vector f2s;
+      expr_ref_vector added_constr;
+      expr_ref_vector assigned_atoms;
+      //END: ASHU
         void init_model();
         void mk_bool_model();
         void mk_value_procs(obj_map<enode, model_value_proc *> & root2proc, ptr_vector<enode> & roots,  ptr_vector<model_value_proc> & procs);
@@ -219,7 +227,11 @@ namespace smt {
         proto_model * mk_model();
 
         obj_map<enode, app *> const & get_root2value() const { return m_root2value; }
-        app * get_value(enode * n) const;
+      app * get_value(enode * n) const;
+      //BEGIN: ASHU
+      void collect_asserted_linear_constr( ast_ref_vector& );
+      app* search_matching_term( func_decl*, func_entry const*);
+      //END: ASHU
     };
 };
 
diff --git a/src/smt/smt_solver.cpp b/src/smt/smt_solver.cpp
index 1778ce0..4b5e472 100644
--- a/src/smt/smt_solver.cpp
+++ b/src/smt/smt_solver.cpp
@@ -21,6 +21,10 @@ Notes:
 #include"reg_decl_plugins.h"
 #include"smt_params.h"
 
+//BEGIN: ASHU
+extern ast_ref_vector* asserted_linear_constr_vector;
+//END: ASHU
+
 namespace smt {
 
     class solver : public solver_na2as {
@@ -74,7 +78,12 @@ namespace smt {
 
         virtual lbool check_sat_core(unsigned num_assumptions, expr * const * assumptions) {
             TRACE("solver_na2as", tout << "smt_solver::check_sat_core: " << num_assumptions << "\n";);
-            return m_context.check(num_assumptions, assumptions);
+            //BEGIN: ASHU
+            lbool res = m_context.check(num_assumptions, assumptions);
+            asserted_linear_constr_vector->reset();
+            m_context.collect_asserted_linear_constr(*asserted_linear_constr_vector);
+            return res;
+            //END: ASHU
         }
 
         virtual void get_unsat_core(ptr_vector<expr> & r) {
diff --git a/src/smt/tactic/smt_tactic.cpp b/src/smt/tactic/smt_tactic.cpp
index 7fa3328..fdb5f4b 100644
--- a/src/smt/tactic/smt_tactic.cpp
+++ b/src/smt/tactic/smt_tactic.cpp
@@ -25,6 +25,10 @@ Notes:
 #include"filter_model_converter.h"
 #include"ast_util.h"
 
+//BEGIN: ASHU
+extern ast_ref_vector* asserted_linear_constr_vector;
+//END: ASHU
+
 typedef obj_map<expr, expr *> expr2expr_map;
 
 void extract_clauses_and_dependencies(goal_ref const& g, expr_ref_vector& clauses, ptr_vector<expr>& assumptions, expr2expr_map& bool2dep, ref<filter_model_converter>& fmc) {
@@ -178,6 +182,10 @@ public:
         ~scoped_init_ctx() {
             smt::kernel * d = m_owner.m_ctx;
             m_owner.m_ctx = 0;
+            //BEGIN: ASHU
+            asserted_linear_constr_vector->reset();
+            d->collect_asserted_linear_constr(*asserted_linear_constr_vector);
+            //END: ASHU
 
             if (d)
                 dealloc(d);
diff --git a/src/smt/theory_arith.h b/src/smt/theory_arith.h
index 39f991c..71a9c63 100644
--- a/src/smt/theory_arith.h
+++ b/src/smt/theory_arith.h
@@ -1103,6 +1103,21 @@ namespace smt {
     public:
         virtual void collect_statistics(::statistics & st) const;
         virtual void display(std::ostream & out) const;
+
+  //BEGIN: ASHU
+      void collect_asserted_atoms( vector< std::pair<bool_var,bool> >& atoms) const {
+        for (unsigned i = 0; i < m_asserted_qhead; i++) {
+            bound * b = m_asserted_bounds[i];
+            if (b->is_atom()) {
+              atom* a = static_cast<atom*>(b);
+              bool_var bv = a->get_bool_var();
+              bool istr = a->is_true();
+              atoms.push_back( std::make_pair(bv,istr) );
+            }
+        }
+    }
+  //END: ASHU
+
     protected:
         void display_row(std::ostream & out, unsigned r_id, bool compact = true) const;
         void display_row(std::ostream & out, row const & r, bool compact = true) const;
